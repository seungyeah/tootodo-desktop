// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: note_model.proto
// Protobuf C++ Version: 5.29.2

#ifndef note_5fmodel_2eproto_2epb_2eh
#define note_5fmodel_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "chat_model.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_note_5fmodel_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_note_5fmodel_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_note_5fmodel_2eproto;
namespace note {
class BlockModel;
struct BlockModelDefaultTypeInternal;
extern BlockModelDefaultTypeInternal _BlockModel_default_instance_;
class NoteModel;
struct NoteModelDefaultTypeInternal;
extern NoteModelDefaultTypeInternal _NoteModel_default_instance_;
class PageModel;
struct PageModelDefaultTypeInternal;
extern PageModelDefaultTypeInternal _PageModel_default_instance_;
class PropValueModel;
struct PropValueModelDefaultTypeInternal;
extern PropValueModelDefaultTypeInternal _PropValueModel_default_instance_;
class PropValueType;
struct PropValueTypeDefaultTypeInternal;
extern PropValueTypeDefaultTypeInternal _PropValueType_default_instance_;
}  // namespace note
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace note {
enum PropertyType : int {
  MULTI_SELECT = 0,
  SINGLE_SELECT = 1,
  TEXT = 2,
  NUMBER = 3,
  DATE_TIME = 4,
  FILE = 5,
  IMAGE = 6,
  LINK = 7,
  EMAIL = 8,
  PHONE = 9,
  LOCATION = 10,
  PropertyType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PropertyType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PropertyType_IsValid(int value);
extern const uint32_t PropertyType_internal_data_[];
constexpr PropertyType PropertyType_MIN = static_cast<PropertyType>(0);
constexpr PropertyType PropertyType_MAX = static_cast<PropertyType>(10);
constexpr int PropertyType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
PropertyType_descriptor();
template <typename T>
const std::string& PropertyType_Name(T value) {
  static_assert(std::is_same<T, PropertyType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PropertyType_Name().");
  return PropertyType_Name(static_cast<PropertyType>(value));
}
template <>
inline const std::string& PropertyType_Name(PropertyType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PropertyType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool PropertyType_Parse(absl::string_view name, PropertyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PropertyType>(
      PropertyType_descriptor(), name, value);
}
enum BlockType : int {
  EDITOR = 0,
  CODE = 1,
  DRAWING = 2,
  TABLE = 3,
  BlockType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BlockType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BlockType_IsValid(int value);
extern const uint32_t BlockType_internal_data_[];
constexpr BlockType BlockType_MIN = static_cast<BlockType>(0);
constexpr BlockType BlockType_MAX = static_cast<BlockType>(3);
constexpr int BlockType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
BlockType_descriptor();
template <typename T>
const std::string& BlockType_Name(T value) {
  static_assert(std::is_same<T, BlockType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BlockType_Name().");
  return BlockType_Name(static_cast<BlockType>(value));
}
template <>
inline const std::string& BlockType_Name(BlockType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BlockType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool BlockType_Parse(absl::string_view name, BlockType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlockType>(
      BlockType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PropValueType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:note.PropValueType) */ {
 public:
  inline PropValueType() : PropValueType(nullptr) {}
  ~PropValueType() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PropValueType* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PropValueType));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PropValueType(
      ::google::protobuf::internal::ConstantInitialized);

  inline PropValueType(const PropValueType& from) : PropValueType(nullptr, from) {}
  inline PropValueType(PropValueType&& from) noexcept
      : PropValueType(nullptr, std::move(from)) {}
  inline PropValueType& operator=(const PropValueType& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropValueType& operator=(PropValueType&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropValueType& default_instance() {
    return *internal_default_instance();
  }
  enum ValueTypeCase {
    kMultiple = 1,
    kSingle = 2,
    VALUE_TYPE_NOT_SET = 0,
  };
  static inline const PropValueType* internal_default_instance() {
    return reinterpret_cast<const PropValueType*>(
        &_PropValueType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(PropValueType& a, PropValueType& b) { a.Swap(&b); }
  inline void Swap(PropValueType* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropValueType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropValueType* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PropValueType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PropValueType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PropValueType& from) { PropValueType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PropValueType* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "note.PropValueType"; }

 protected:
  explicit PropValueType(::google::protobuf::Arena* arena);
  PropValueType(::google::protobuf::Arena* arena, const PropValueType& from);
  PropValueType(::google::protobuf::Arena* arena, PropValueType&& from) noexcept
      : PropValueType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMultipleFieldNumber = 1,
    kSingleFieldNumber = 2,
  };
  // string multiple = 1;
  bool has_multiple() const;
  void clear_multiple() ;
  const std::string& multiple() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_multiple(Arg_&& arg, Args_... args);
  std::string* mutable_multiple();
  PROTOBUF_NODISCARD std::string* release_multiple();
  void set_allocated_multiple(std::string* value);

  private:
  const std::string& _internal_multiple() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_multiple(
      const std::string& value);
  std::string* _internal_mutable_multiple();

  public:
  // string single = 2;
  bool has_single() const;
  void clear_single() ;
  const std::string& single() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_single(Arg_&& arg, Args_... args);
  std::string* mutable_single();
  PROTOBUF_NODISCARD std::string* release_single();
  void set_allocated_single(std::string* value);

  private:
  const std::string& _internal_single() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_single(
      const std::string& value);
  std::string* _internal_mutable_single();

  public:
  void clear_value_type();
  ValueTypeCase value_type_case() const;
  // @@protoc_insertion_point(class_scope:note.PropValueType)
 private:
  class _Internal;
  void set_has_multiple();
  void set_has_single();
  inline bool has_value_type() const;
  inline void clear_has_value_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 0,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PropValueType& from_msg);
    union ValueTypeUnion {
      constexpr ValueTypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr multiple_;
      ::google::protobuf::internal::ArenaStringPtr single_;
    } value_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_note_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class BlockModel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:note.BlockModel) */ {
 public:
  inline BlockModel() : BlockModel(nullptr) {}
  ~BlockModel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockModel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockModel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockModel(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockModel(const BlockModel& from) : BlockModel(nullptr, from) {}
  inline BlockModel(BlockModel&& from) noexcept
      : BlockModel(nullptr, std::move(from)) {}
  inline BlockModel& operator=(const BlockModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockModel& operator=(BlockModel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockModel* internal_default_instance() {
    return reinterpret_cast<const BlockModel*>(
        &_BlockModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(BlockModel& a, BlockModel& b) { a.Swap(&b); }
  inline void Swap(BlockModel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockModel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockModel& from) { BlockModel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockModel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "note.BlockModel"; }

 protected:
  explicit BlockModel(::google::protobuf::Arena* arena);
  BlockModel(::google::protobuf::Arena* arena, const BlockModel& from);
  BlockModel(::google::protobuf::Arena* arena, BlockModel&& from) noexcept
      : BlockModel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kSrcTaskIdFieldNumber = 2,
    kBodyFieldNumber = 4,
    kBlockTypeFieldNumber = 3,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string src_task_id = 2;
  void clear_src_task_id() ;
  const std::string& src_task_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_task_id(Arg_&& arg, Args_... args);
  std::string* mutable_src_task_id();
  PROTOBUF_NODISCARD std::string* release_src_task_id();
  void set_allocated_src_task_id(std::string* value);

  private:
  const std::string& _internal_src_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_task_id(
      const std::string& value);
  std::string* _internal_mutable_src_task_id();

  public:
  // string body = 4;
  void clear_body() ;
  const std::string& body() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_body(Arg_&& arg, Args_... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* value);

  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(
      const std::string& value);
  std::string* _internal_mutable_body();

  public:
  // .note.BlockType block_type = 3;
  void clear_block_type() ;
  ::note::BlockType block_type() const;
  void set_block_type(::note::BlockType value);

  private:
  ::note::BlockType _internal_block_type() const;
  void _internal_set_block_type(::note::BlockType value);

  public:
  // @@protoc_insertion_point(class_scope:note.BlockModel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockModel& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr src_task_id_;
    ::google::protobuf::internal::ArenaStringPtr body_;
    int block_type_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_note_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class PropValueModel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:note.PropValueModel) */ {
 public:
  inline PropValueModel() : PropValueModel(nullptr) {}
  ~PropValueModel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PropValueModel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PropValueModel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PropValueModel(
      ::google::protobuf::internal::ConstantInitialized);

  inline PropValueModel(const PropValueModel& from) : PropValueModel(nullptr, from) {}
  inline PropValueModel(PropValueModel&& from) noexcept
      : PropValueModel(nullptr, std::move(from)) {}
  inline PropValueModel& operator=(const PropValueModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline PropValueModel& operator=(PropValueModel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PropValueModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const PropValueModel* internal_default_instance() {
    return reinterpret_cast<const PropValueModel*>(
        &_PropValueModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PropValueModel& a, PropValueModel& b) { a.Swap(&b); }
  inline void Swap(PropValueModel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PropValueModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PropValueModel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PropValueModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PropValueModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PropValueModel& from) { PropValueModel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PropValueModel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "note.PropValueModel"; }

 protected:
  explicit PropValueModel(::google::protobuf::Arena* arena);
  PropValueModel(::google::protobuf::Arena* arena, const PropValueModel& from);
  PropValueModel(::google::protobuf::Arena* arena, PropValueModel&& from) noexcept
      : PropValueModel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPropIdFieldNumber = 1,
    kPropNameFieldNumber = 2,
    kValuesFieldNumber = 4,
    kPropTypeFieldNumber = 3,
  };
  // string prop_id = 1;
  void clear_prop_id() ;
  const std::string& prop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prop_id(Arg_&& arg, Args_... args);
  std::string* mutable_prop_id();
  PROTOBUF_NODISCARD std::string* release_prop_id();
  void set_allocated_prop_id(std::string* value);

  private:
  const std::string& _internal_prop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prop_id(
      const std::string& value);
  std::string* _internal_mutable_prop_id();

  public:
  // string prop_name = 2;
  void clear_prop_name() ;
  const std::string& prop_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prop_name(Arg_&& arg, Args_... args);
  std::string* mutable_prop_name();
  PROTOBUF_NODISCARD std::string* release_prop_name();
  void set_allocated_prop_name(std::string* value);

  private:
  const std::string& _internal_prop_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prop_name(
      const std::string& value);
  std::string* _internal_mutable_prop_name();

  public:
  // .note.PropValueType values = 4;
  bool has_values() const;
  void clear_values() ;
  const ::note::PropValueType& values() const;
  PROTOBUF_NODISCARD ::note::PropValueType* release_values();
  ::note::PropValueType* mutable_values();
  void set_allocated_values(::note::PropValueType* value);
  void unsafe_arena_set_allocated_values(::note::PropValueType* value);
  ::note::PropValueType* unsafe_arena_release_values();

  private:
  const ::note::PropValueType& _internal_values() const;
  ::note::PropValueType* _internal_mutable_values();

  public:
  // .note.PropertyType prop_type = 3;
  void clear_prop_type() ;
  ::note::PropertyType prop_type() const;
  void set_prop_type(::note::PropertyType value);

  private:
  ::note::PropertyType _internal_prop_type() const;
  void _internal_set_prop_type(::note::PropertyType value);

  public:
  // @@protoc_insertion_point(class_scope:note.PropValueModel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      44, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PropValueModel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr prop_id_;
    ::google::protobuf::internal::ArenaStringPtr prop_name_;
    ::note::PropValueType* values_;
    int prop_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_note_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class PageModel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:note.PageModel) */ {
 public:
  inline PageModel() : PageModel(nullptr) {}
  ~PageModel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PageModel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PageModel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PageModel(
      ::google::protobuf::internal::ConstantInitialized);

  inline PageModel(const PageModel& from) : PageModel(nullptr, from) {}
  inline PageModel(PageModel&& from) noexcept
      : PageModel(nullptr, std::move(from)) {}
  inline PageModel& operator=(const PageModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline PageModel& operator=(PageModel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PageModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const PageModel* internal_default_instance() {
    return reinterpret_cast<const PageModel*>(
        &_PageModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(PageModel& a, PageModel& b) { a.Swap(&b); }
  inline void Swap(PageModel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PageModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PageModel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PageModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PageModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PageModel& from) { PageModel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PageModel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "note.PageModel"; }

 protected:
  explicit PageModel(::google::protobuf::Arena* arena);
  PageModel(::google::protobuf::Arena* arena, const PageModel& from);
  PageModel(::google::protobuf::Arena* arena, PageModel&& from) noexcept
      : PageModel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kContentsFieldNumber = 5,
    kIdFieldNumber = 1,
    kUserFieldNumber = 2,
    kTitleFieldNumber = 3,
    kConnectedNoteFieldNumber = 4,
    kCreatedAtFieldNumber = 6,
    kUpdatedAtFieldNumber = 7,
  };
  // repeated .note.BlockModel contents = 5;
  int contents_size() const;
  private:
  int _internal_contents_size() const;

  public:
  void clear_contents() ;
  ::note::BlockModel* mutable_contents(int index);
  ::google::protobuf::RepeatedPtrField<::note::BlockModel>* mutable_contents();

  private:
  const ::google::protobuf::RepeatedPtrField<::note::BlockModel>& _internal_contents() const;
  ::google::protobuf::RepeatedPtrField<::note::BlockModel>* _internal_mutable_contents();
  public:
  const ::note::BlockModel& contents(int index) const;
  ::note::BlockModel* add_contents();
  const ::google::protobuf::RepeatedPtrField<::note::BlockModel>& contents() const;
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string user = 2;
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // string title = 3;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string connected_note = 4;
  void clear_connected_note() ;
  const std::string& connected_note() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connected_note(Arg_&& arg, Args_... args);
  std::string* mutable_connected_note();
  PROTOBUF_NODISCARD std::string* release_connected_note();
  void set_allocated_connected_note(std::string* value);

  private:
  const std::string& _internal_connected_note() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connected_note(
      const std::string& value);
  std::string* _internal_mutable_connected_note();

  public:
  // .google.protobuf.Timestamp createdAt = 6;
  bool has_createdat() const;
  void clear_createdat() ;
  const ::google::protobuf::Timestamp& createdat() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_createdat();
  ::google::protobuf::Timestamp* mutable_createdat();
  void set_allocated_createdat(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_createdat(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_createdat();

  private:
  const ::google::protobuf::Timestamp& _internal_createdat() const;
  ::google::protobuf::Timestamp* _internal_mutable_createdat();

  public:
  // .google.protobuf.Timestamp updatedAt = 7;
  bool has_updatedat() const;
  void clear_updatedat() ;
  const ::google::protobuf::Timestamp& updatedat() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updatedat();
  ::google::protobuf::Timestamp* mutable_updatedat();
  void set_allocated_updatedat(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updatedat(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updatedat();

  private:
  const ::google::protobuf::Timestamp& _internal_updatedat() const;
  ::google::protobuf::Timestamp* _internal_mutable_updatedat();

  public:
  // @@protoc_insertion_point(class_scope:note.PageModel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      48, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PageModel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::note::BlockModel > contents_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr user_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr connected_note_;
    ::google::protobuf::Timestamp* createdat_;
    ::google::protobuf::Timestamp* updatedat_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_note_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class NoteModel final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:note.NoteModel) */ {
 public:
  inline NoteModel() : NoteModel(nullptr) {}
  ~NoteModel() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NoteModel* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NoteModel));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NoteModel(
      ::google::protobuf::internal::ConstantInitialized);

  inline NoteModel(const NoteModel& from) : NoteModel(nullptr, from) {}
  inline NoteModel(NoteModel&& from) noexcept
      : NoteModel(nullptr, std::move(from)) {}
  inline NoteModel& operator=(const NoteModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoteModel& operator=(NoteModel&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoteModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoteModel* internal_default_instance() {
    return reinterpret_cast<const NoteModel*>(
        &_NoteModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(NoteModel& a, NoteModel& b) { a.Swap(&b); }
  inline void Swap(NoteModel* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoteModel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoteModel* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NoteModel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NoteModel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NoteModel& from) { NoteModel::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NoteModel* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "note.NoteModel"; }

 protected:
  explicit NoteModel(::google::protobuf::Arena* arena);
  NoteModel(::google::protobuf::Arena* arena, const NoteModel& from);
  NoteModel(::google::protobuf::Arena* arena, NoteModel&& from) noexcept
      : NoteModel(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPropValuesFieldNumber = 7,
    kPagesFieldNumber = 8,
    kChatMsgsFieldNumber = 12,
    kIdFieldNumber = 1,
    kUserFieldNumber = 2,
    kTitleFieldNumber = 3,
    kCategoryIdFieldNumber = 4,
    kCategoryColorFieldNumber = 5,
    kCategoryNameFieldNumber = 6,
    kConnectedTaskFieldNumber = 9,
    kParentIdFieldNumber = 10,
    kCreatedAtFieldNumber = 13,
    kUpdatedAtFieldNumber = 14,
    kChatTypeFieldNumber = 11,
  };
  // repeated .note.PropValueModel prop_values = 7;
  int prop_values_size() const;
  private:
  int _internal_prop_values_size() const;

  public:
  void clear_prop_values() ;
  ::note::PropValueModel* mutable_prop_values(int index);
  ::google::protobuf::RepeatedPtrField<::note::PropValueModel>* mutable_prop_values();

  private:
  const ::google::protobuf::RepeatedPtrField<::note::PropValueModel>& _internal_prop_values() const;
  ::google::protobuf::RepeatedPtrField<::note::PropValueModel>* _internal_mutable_prop_values();
  public:
  const ::note::PropValueModel& prop_values(int index) const;
  ::note::PropValueModel* add_prop_values();
  const ::google::protobuf::RepeatedPtrField<::note::PropValueModel>& prop_values() const;
  // repeated .note.PageModel pages = 8;
  int pages_size() const;
  private:
  int _internal_pages_size() const;

  public:
  void clear_pages() ;
  ::note::PageModel* mutable_pages(int index);
  ::google::protobuf::RepeatedPtrField<::note::PageModel>* mutable_pages();

  private:
  const ::google::protobuf::RepeatedPtrField<::note::PageModel>& _internal_pages() const;
  ::google::protobuf::RepeatedPtrField<::note::PageModel>* _internal_mutable_pages();
  public:
  const ::note::PageModel& pages(int index) const;
  ::note::PageModel* add_pages();
  const ::google::protobuf::RepeatedPtrField<::note::PageModel>& pages() const;
  // repeated .chat.MsgModel chat_msgs = 12;
  int chat_msgs_size() const;
  private:
  int _internal_chat_msgs_size() const;

  public:
  void clear_chat_msgs() ;
  ::chat::MsgModel* mutable_chat_msgs(int index);
  ::google::protobuf::RepeatedPtrField<::chat::MsgModel>* mutable_chat_msgs();

  private:
  const ::google::protobuf::RepeatedPtrField<::chat::MsgModel>& _internal_chat_msgs() const;
  ::google::protobuf::RepeatedPtrField<::chat::MsgModel>* _internal_mutable_chat_msgs();
  public:
  const ::chat::MsgModel& chat_msgs(int index) const;
  ::chat::MsgModel* add_chat_msgs();
  const ::google::protobuf::RepeatedPtrField<::chat::MsgModel>& chat_msgs() const;
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string user = 2;
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // string title = 3;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string category_id = 4;
  void clear_category_id() ;
  const std::string& category_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category_id(Arg_&& arg, Args_... args);
  std::string* mutable_category_id();
  PROTOBUF_NODISCARD std::string* release_category_id();
  void set_allocated_category_id(std::string* value);

  private:
  const std::string& _internal_category_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category_id(
      const std::string& value);
  std::string* _internal_mutable_category_id();

  public:
  // string category_color = 5;
  void clear_category_color() ;
  const std::string& category_color() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category_color(Arg_&& arg, Args_... args);
  std::string* mutable_category_color();
  PROTOBUF_NODISCARD std::string* release_category_color();
  void set_allocated_category_color(std::string* value);

  private:
  const std::string& _internal_category_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category_color(
      const std::string& value);
  std::string* _internal_mutable_category_color();

  public:
  // string category_name = 6;
  void clear_category_name() ;
  const std::string& category_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_category_name(Arg_&& arg, Args_... args);
  std::string* mutable_category_name();
  PROTOBUF_NODISCARD std::string* release_category_name();
  void set_allocated_category_name(std::string* value);

  private:
  const std::string& _internal_category_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category_name(
      const std::string& value);
  std::string* _internal_mutable_category_name();

  public:
  // string connected_task = 9;
  void clear_connected_task() ;
  const std::string& connected_task() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connected_task(Arg_&& arg, Args_... args);
  std::string* mutable_connected_task();
  PROTOBUF_NODISCARD std::string* release_connected_task();
  void set_allocated_connected_task(std::string* value);

  private:
  const std::string& _internal_connected_task() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connected_task(
      const std::string& value);
  std::string* _internal_mutable_connected_task();

  public:
  // string parent_id = 10;
  void clear_parent_id() ;
  const std::string& parent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_id(Arg_&& arg, Args_... args);
  std::string* mutable_parent_id();
  PROTOBUF_NODISCARD std::string* release_parent_id();
  void set_allocated_parent_id(std::string* value);

  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(
      const std::string& value);
  std::string* _internal_mutable_parent_id();

  public:
  // .google.protobuf.Timestamp createdAt = 13;
  bool has_createdat() const;
  void clear_createdat() ;
  const ::google::protobuf::Timestamp& createdat() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_createdat();
  ::google::protobuf::Timestamp* mutable_createdat();
  void set_allocated_createdat(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_createdat(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_createdat();

  private:
  const ::google::protobuf::Timestamp& _internal_createdat() const;
  ::google::protobuf::Timestamp* _internal_mutable_createdat();

  public:
  // .google.protobuf.Timestamp updatedAt = 14;
  bool has_updatedat() const;
  void clear_updatedat() ;
  const ::google::protobuf::Timestamp& updatedat() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updatedat();
  ::google::protobuf::Timestamp* mutable_updatedat();
  void set_allocated_updatedat(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updatedat(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updatedat();

  private:
  const ::google::protobuf::Timestamp& _internal_updatedat() const;
  ::google::protobuf::Timestamp* _internal_mutable_updatedat();

  public:
  // .chat.ChatType chat_type = 11;
  void clear_chat_type() ;
  ::chat::ChatType chat_type() const;
  void set_chat_type(::chat::ChatType value);

  private:
  ::chat::ChatType _internal_chat_type() const;
  void _internal_set_chat_type(::chat::ChatType value);

  public:
  // @@protoc_insertion_point(class_scope:note.NoteModel)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 5,
      103, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NoteModel& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::note::PropValueModel > prop_values_;
    ::google::protobuf::RepeatedPtrField< ::note::PageModel > pages_;
    ::google::protobuf::RepeatedPtrField< ::chat::MsgModel > chat_msgs_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr user_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr category_id_;
    ::google::protobuf::internal::ArenaStringPtr category_color_;
    ::google::protobuf::internal::ArenaStringPtr category_name_;
    ::google::protobuf::internal::ArenaStringPtr connected_task_;
    ::google::protobuf::internal::ArenaStringPtr parent_id_;
    ::google::protobuf::Timestamp* createdat_;
    ::google::protobuf::Timestamp* updatedat_;
    int chat_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_note_5fmodel_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NoteModel

// string id = 1;
inline void NoteModel::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& NoteModel::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteModel::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.NoteModel.id)
}
inline std::string* NoteModel::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:note.NoteModel.id)
  return _s;
}
inline const std::string& NoteModel::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void NoteModel::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* NoteModel::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* NoteModel::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.NoteModel.id)
  return _impl_.id_.Release();
}
inline void NoteModel::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.NoteModel.id)
}

// string user = 2;
inline void NoteModel::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.ClearToEmpty();
}
inline const std::string& NoteModel::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteModel::set_user(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.NoteModel.user)
}
inline std::string* NoteModel::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:note.NoteModel.user)
  return _s;
}
inline const std::string& NoteModel::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_.Get();
}
inline void NoteModel::_internal_set_user(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(value, GetArena());
}
inline std::string* NoteModel::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* NoteModel::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.NoteModel.user)
  return _impl_.user_.Release();
}
inline void NoteModel::set_allocated_user(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.NoteModel.user)
}

// string title = 3;
inline void NoteModel::clear_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.ClearToEmpty();
}
inline const std::string& NoteModel::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteModel::set_title(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.NoteModel.title)
}
inline std::string* NoteModel::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:note.NoteModel.title)
  return _s;
}
inline const std::string& NoteModel::_internal_title() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.title_.Get();
}
inline void NoteModel::_internal_set_title(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.Set(value, GetArena());
}
inline std::string* NoteModel::_internal_mutable_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* NoteModel::release_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.NoteModel.title)
  return _impl_.title_.Release();
}
inline void NoteModel::set_allocated_title(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.NoteModel.title)
}

// string category_id = 4;
inline void NoteModel::clear_category_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_id_.ClearToEmpty();
}
inline const std::string& NoteModel::category_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.category_id)
  return _internal_category_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteModel::set_category_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.NoteModel.category_id)
}
inline std::string* NoteModel::mutable_category_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category_id();
  // @@protoc_insertion_point(field_mutable:note.NoteModel.category_id)
  return _s;
}
inline const std::string& NoteModel::_internal_category_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.category_id_.Get();
}
inline void NoteModel::_internal_set_category_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_id_.Set(value, GetArena());
}
inline std::string* NoteModel::_internal_mutable_category_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.category_id_.Mutable( GetArena());
}
inline std::string* NoteModel::release_category_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.NoteModel.category_id)
  return _impl_.category_id_.Release();
}
inline void NoteModel::set_allocated_category_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.category_id_.IsDefault()) {
    _impl_.category_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.NoteModel.category_id)
}

// string category_color = 5;
inline void NoteModel::clear_category_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_color_.ClearToEmpty();
}
inline const std::string& NoteModel::category_color() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.category_color)
  return _internal_category_color();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteModel::set_category_color(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_color_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.NoteModel.category_color)
}
inline std::string* NoteModel::mutable_category_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category_color();
  // @@protoc_insertion_point(field_mutable:note.NoteModel.category_color)
  return _s;
}
inline const std::string& NoteModel::_internal_category_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.category_color_.Get();
}
inline void NoteModel::_internal_set_category_color(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_color_.Set(value, GetArena());
}
inline std::string* NoteModel::_internal_mutable_category_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.category_color_.Mutable( GetArena());
}
inline std::string* NoteModel::release_category_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.NoteModel.category_color)
  return _impl_.category_color_.Release();
}
inline void NoteModel::set_allocated_category_color(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_color_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.category_color_.IsDefault()) {
    _impl_.category_color_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.NoteModel.category_color)
}

// string category_name = 6;
inline void NoteModel::clear_category_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_name_.ClearToEmpty();
}
inline const std::string& NoteModel::category_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.category_name)
  return _internal_category_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteModel::set_category_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.NoteModel.category_name)
}
inline std::string* NoteModel::mutable_category_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_category_name();
  // @@protoc_insertion_point(field_mutable:note.NoteModel.category_name)
  return _s;
}
inline const std::string& NoteModel::_internal_category_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.category_name_.Get();
}
inline void NoteModel::_internal_set_category_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_name_.Set(value, GetArena());
}
inline std::string* NoteModel::_internal_mutable_category_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.category_name_.Mutable( GetArena());
}
inline std::string* NoteModel::release_category_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.NoteModel.category_name)
  return _impl_.category_name_.Release();
}
inline void NoteModel::set_allocated_category_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.category_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.category_name_.IsDefault()) {
    _impl_.category_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.NoteModel.category_name)
}

// repeated .note.PropValueModel prop_values = 7;
inline int NoteModel::_internal_prop_values_size() const {
  return _internal_prop_values().size();
}
inline int NoteModel::prop_values_size() const {
  return _internal_prop_values_size();
}
inline void NoteModel::clear_prop_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_values_.Clear();
}
inline ::note::PropValueModel* NoteModel::mutable_prop_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:note.NoteModel.prop_values)
  return _internal_mutable_prop_values()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::note::PropValueModel>* NoteModel::mutable_prop_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:note.NoteModel.prop_values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_prop_values();
}
inline const ::note::PropValueModel& NoteModel::prop_values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.prop_values)
  return _internal_prop_values().Get(index);
}
inline ::note::PropValueModel* NoteModel::add_prop_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::note::PropValueModel* _add = _internal_mutable_prop_values()->Add();
  // @@protoc_insertion_point(field_add:note.NoteModel.prop_values)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::note::PropValueModel>& NoteModel::prop_values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:note.NoteModel.prop_values)
  return _internal_prop_values();
}
inline const ::google::protobuf::RepeatedPtrField<::note::PropValueModel>&
NoteModel::_internal_prop_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prop_values_;
}
inline ::google::protobuf::RepeatedPtrField<::note::PropValueModel>*
NoteModel::_internal_mutable_prop_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.prop_values_;
}

// repeated .note.PageModel pages = 8;
inline int NoteModel::_internal_pages_size() const {
  return _internal_pages().size();
}
inline int NoteModel::pages_size() const {
  return _internal_pages_size();
}
inline void NoteModel::clear_pages() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pages_.Clear();
}
inline ::note::PageModel* NoteModel::mutable_pages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:note.NoteModel.pages)
  return _internal_mutable_pages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::note::PageModel>* NoteModel::mutable_pages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:note.NoteModel.pages)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_pages();
}
inline const ::note::PageModel& NoteModel::pages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.pages)
  return _internal_pages().Get(index);
}
inline ::note::PageModel* NoteModel::add_pages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::note::PageModel* _add = _internal_mutable_pages()->Add();
  // @@protoc_insertion_point(field_add:note.NoteModel.pages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::note::PageModel>& NoteModel::pages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:note.NoteModel.pages)
  return _internal_pages();
}
inline const ::google::protobuf::RepeatedPtrField<::note::PageModel>&
NoteModel::_internal_pages() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pages_;
}
inline ::google::protobuf::RepeatedPtrField<::note::PageModel>*
NoteModel::_internal_mutable_pages() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.pages_;
}

// string connected_task = 9;
inline void NoteModel::clear_connected_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connected_task_.ClearToEmpty();
}
inline const std::string& NoteModel::connected_task() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.connected_task)
  return _internal_connected_task();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteModel::set_connected_task(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connected_task_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.NoteModel.connected_task)
}
inline std::string* NoteModel::mutable_connected_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connected_task();
  // @@protoc_insertion_point(field_mutable:note.NoteModel.connected_task)
  return _s;
}
inline const std::string& NoteModel::_internal_connected_task() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connected_task_.Get();
}
inline void NoteModel::_internal_set_connected_task(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connected_task_.Set(value, GetArena());
}
inline std::string* NoteModel::_internal_mutable_connected_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.connected_task_.Mutable( GetArena());
}
inline std::string* NoteModel::release_connected_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.NoteModel.connected_task)
  return _impl_.connected_task_.Release();
}
inline void NoteModel::set_allocated_connected_task(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connected_task_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.connected_task_.IsDefault()) {
    _impl_.connected_task_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.NoteModel.connected_task)
}

// string parent_id = 10;
inline void NoteModel::clear_parent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_id_.ClearToEmpty();
}
inline const std::string& NoteModel::parent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.parent_id)
  return _internal_parent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NoteModel::set_parent_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.NoteModel.parent_id)
}
inline std::string* NoteModel::mutable_parent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:note.NoteModel.parent_id)
  return _s;
}
inline const std::string& NoteModel::_internal_parent_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_id_.Get();
}
inline void NoteModel::_internal_set_parent_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_id_.Set(value, GetArena());
}
inline std::string* NoteModel::_internal_mutable_parent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parent_id_.Mutable( GetArena());
}
inline std::string* NoteModel::release_parent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.NoteModel.parent_id)
  return _impl_.parent_id_.Release();
}
inline void NoteModel::set_allocated_parent_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_id_.IsDefault()) {
    _impl_.parent_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.NoteModel.parent_id)
}

// .chat.ChatType chat_type = 11;
inline void NoteModel::clear_chat_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chat_type_ = 0;
}
inline ::chat::ChatType NoteModel::chat_type() const {
  // @@protoc_insertion_point(field_get:note.NoteModel.chat_type)
  return _internal_chat_type();
}
inline void NoteModel::set_chat_type(::chat::ChatType value) {
  _internal_set_chat_type(value);
  // @@protoc_insertion_point(field_set:note.NoteModel.chat_type)
}
inline ::chat::ChatType NoteModel::_internal_chat_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::chat::ChatType>(_impl_.chat_type_);
}
inline void NoteModel::_internal_set_chat_type(::chat::ChatType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chat_type_ = value;
}

// repeated .chat.MsgModel chat_msgs = 12;
inline int NoteModel::_internal_chat_msgs_size() const {
  return _internal_chat_msgs().size();
}
inline int NoteModel::chat_msgs_size() const {
  return _internal_chat_msgs_size();
}
inline ::chat::MsgModel* NoteModel::mutable_chat_msgs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:note.NoteModel.chat_msgs)
  return _internal_mutable_chat_msgs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chat::MsgModel>* NoteModel::mutable_chat_msgs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:note.NoteModel.chat_msgs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_chat_msgs();
}
inline const ::chat::MsgModel& NoteModel::chat_msgs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.chat_msgs)
  return _internal_chat_msgs().Get(index);
}
inline ::chat::MsgModel* NoteModel::add_chat_msgs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chat::MsgModel* _add = _internal_mutable_chat_msgs()->Add();
  // @@protoc_insertion_point(field_add:note.NoteModel.chat_msgs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chat::MsgModel>& NoteModel::chat_msgs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:note.NoteModel.chat_msgs)
  return _internal_chat_msgs();
}
inline const ::google::protobuf::RepeatedPtrField<::chat::MsgModel>&
NoteModel::_internal_chat_msgs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.chat_msgs_;
}
inline ::google::protobuf::RepeatedPtrField<::chat::MsgModel>*
NoteModel::_internal_mutable_chat_msgs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.chat_msgs_;
}

// .google.protobuf.Timestamp createdAt = 13;
inline bool NoteModel::has_createdat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.createdat_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& NoteModel::_internal_createdat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.createdat_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& NoteModel::createdat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.createdAt)
  return _internal_createdat();
}
inline void NoteModel::unsafe_arena_set_allocated_createdat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.createdat_);
  }
  _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:note.NoteModel.createdAt)
}
inline ::google::protobuf::Timestamp* NoteModel::release_createdat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.createdat_;
  _impl_.createdat_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* NoteModel::unsafe_arena_release_createdat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.NoteModel.createdAt)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.createdat_;
  _impl_.createdat_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* NoteModel::_internal_mutable_createdat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.createdat_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.createdat_;
}
inline ::google::protobuf::Timestamp* NoteModel::mutable_createdat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_createdat();
  // @@protoc_insertion_point(field_mutable:note.NoteModel.createdAt)
  return _msg;
}
inline void NoteModel::set_allocated_createdat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.createdat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:note.NoteModel.createdAt)
}

// .google.protobuf.Timestamp updatedAt = 14;
inline bool NoteModel::has_updatedat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updatedat_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& NoteModel::_internal_updatedat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.updatedat_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& NoteModel::updatedat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.NoteModel.updatedAt)
  return _internal_updatedat();
}
inline void NoteModel::unsafe_arena_set_allocated_updatedat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updatedat_);
  }
  _impl_.updatedat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:note.NoteModel.updatedAt)
}
inline ::google::protobuf::Timestamp* NoteModel::release_updatedat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updatedat_;
  _impl_.updatedat_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* NoteModel::unsafe_arena_release_updatedat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.NoteModel.updatedAt)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updatedat_;
  _impl_.updatedat_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* NoteModel::_internal_mutable_updatedat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updatedat_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.updatedat_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updatedat_;
}
inline ::google::protobuf::Timestamp* NoteModel::mutable_updatedat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updatedat();
  // @@protoc_insertion_point(field_mutable:note.NoteModel.updatedAt)
  return _msg;
}
inline void NoteModel::set_allocated_updatedat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updatedat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updatedat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:note.NoteModel.updatedAt)
}

// -------------------------------------------------------------------

// PageModel

// string id = 1;
inline void PageModel::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& PageModel::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PageModel.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PageModel::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.PageModel.id)
}
inline std::string* PageModel::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:note.PageModel.id)
  return _s;
}
inline const std::string& PageModel::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void PageModel::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* PageModel::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* PageModel::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PageModel.id)
  return _impl_.id_.Release();
}
inline void PageModel::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.PageModel.id)
}

// string user = 2;
inline void PageModel::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.ClearToEmpty();
}
inline const std::string& PageModel::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PageModel.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PageModel::set_user(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.PageModel.user)
}
inline std::string* PageModel::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:note.PageModel.user)
  return _s;
}
inline const std::string& PageModel::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_.Get();
}
inline void PageModel::_internal_set_user(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.Set(value, GetArena());
}
inline std::string* PageModel::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* PageModel::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PageModel.user)
  return _impl_.user_.Release();
}
inline void PageModel::set_allocated_user(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.PageModel.user)
}

// string title = 3;
inline void PageModel::clear_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.ClearToEmpty();
}
inline const std::string& PageModel::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PageModel.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PageModel::set_title(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.PageModel.title)
}
inline std::string* PageModel::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:note.PageModel.title)
  return _s;
}
inline const std::string& PageModel::_internal_title() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.title_.Get();
}
inline void PageModel::_internal_set_title(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.Set(value, GetArena());
}
inline std::string* PageModel::_internal_mutable_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* PageModel::release_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PageModel.title)
  return _impl_.title_.Release();
}
inline void PageModel::set_allocated_title(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.PageModel.title)
}

// string connected_note = 4;
inline void PageModel::clear_connected_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connected_note_.ClearToEmpty();
}
inline const std::string& PageModel::connected_note() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PageModel.connected_note)
  return _internal_connected_note();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PageModel::set_connected_note(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connected_note_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.PageModel.connected_note)
}
inline std::string* PageModel::mutable_connected_note() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connected_note();
  // @@protoc_insertion_point(field_mutable:note.PageModel.connected_note)
  return _s;
}
inline const std::string& PageModel::_internal_connected_note() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connected_note_.Get();
}
inline void PageModel::_internal_set_connected_note(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connected_note_.Set(value, GetArena());
}
inline std::string* PageModel::_internal_mutable_connected_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.connected_note_.Mutable( GetArena());
}
inline std::string* PageModel::release_connected_note() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PageModel.connected_note)
  return _impl_.connected_note_.Release();
}
inline void PageModel::set_allocated_connected_note(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connected_note_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.connected_note_.IsDefault()) {
    _impl_.connected_note_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.PageModel.connected_note)
}

// repeated .note.BlockModel contents = 5;
inline int PageModel::_internal_contents_size() const {
  return _internal_contents().size();
}
inline int PageModel::contents_size() const {
  return _internal_contents_size();
}
inline void PageModel::clear_contents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.contents_.Clear();
}
inline ::note::BlockModel* PageModel::mutable_contents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:note.PageModel.contents)
  return _internal_mutable_contents()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::note::BlockModel>* PageModel::mutable_contents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:note.PageModel.contents)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_contents();
}
inline const ::note::BlockModel& PageModel::contents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PageModel.contents)
  return _internal_contents().Get(index);
}
inline ::note::BlockModel* PageModel::add_contents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::note::BlockModel* _add = _internal_mutable_contents()->Add();
  // @@protoc_insertion_point(field_add:note.PageModel.contents)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::note::BlockModel>& PageModel::contents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:note.PageModel.contents)
  return _internal_contents();
}
inline const ::google::protobuf::RepeatedPtrField<::note::BlockModel>&
PageModel::_internal_contents() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.contents_;
}
inline ::google::protobuf::RepeatedPtrField<::note::BlockModel>*
PageModel::_internal_mutable_contents() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.contents_;
}

// .google.protobuf.Timestamp createdAt = 6;
inline bool PageModel::has_createdat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.createdat_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& PageModel::_internal_createdat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.createdat_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& PageModel::createdat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PageModel.createdAt)
  return _internal_createdat();
}
inline void PageModel::unsafe_arena_set_allocated_createdat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.createdat_);
  }
  _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:note.PageModel.createdAt)
}
inline ::google::protobuf::Timestamp* PageModel::release_createdat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.createdat_;
  _impl_.createdat_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PageModel::unsafe_arena_release_createdat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PageModel.createdAt)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.createdat_;
  _impl_.createdat_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PageModel::_internal_mutable_createdat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.createdat_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.createdat_;
}
inline ::google::protobuf::Timestamp* PageModel::mutable_createdat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_createdat();
  // @@protoc_insertion_point(field_mutable:note.PageModel.createdAt)
  return _msg;
}
inline void PageModel::set_allocated_createdat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.createdat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.createdat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:note.PageModel.createdAt)
}

// .google.protobuf.Timestamp updatedAt = 7;
inline bool PageModel::has_updatedat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updatedat_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& PageModel::_internal_updatedat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.updatedat_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& PageModel::updatedat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PageModel.updatedAt)
  return _internal_updatedat();
}
inline void PageModel::unsafe_arena_set_allocated_updatedat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updatedat_);
  }
  _impl_.updatedat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:note.PageModel.updatedAt)
}
inline ::google::protobuf::Timestamp* PageModel::release_updatedat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updatedat_;
  _impl_.updatedat_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PageModel::unsafe_arena_release_updatedat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PageModel.updatedAt)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updatedat_;
  _impl_.updatedat_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PageModel::_internal_mutable_updatedat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updatedat_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.updatedat_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updatedat_;
}
inline ::google::protobuf::Timestamp* PageModel::mutable_updatedat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updatedat();
  // @@protoc_insertion_point(field_mutable:note.PageModel.updatedAt)
  return _msg;
}
inline void PageModel::set_allocated_updatedat(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updatedat_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updatedat_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:note.PageModel.updatedAt)
}

// -------------------------------------------------------------------

// BlockModel

// string id = 1;
inline void BlockModel::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BlockModel::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.BlockModel.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockModel::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.BlockModel.id)
}
inline std::string* BlockModel::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:note.BlockModel.id)
  return _s;
}
inline const std::string& BlockModel::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void BlockModel::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* BlockModel::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* BlockModel::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.BlockModel.id)
  return _impl_.id_.Release();
}
inline void BlockModel::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.BlockModel.id)
}

// string src_task_id = 2;
inline void BlockModel::clear_src_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_task_id_.ClearToEmpty();
}
inline const std::string& BlockModel::src_task_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.BlockModel.src_task_id)
  return _internal_src_task_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockModel::set_src_task_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_task_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.BlockModel.src_task_id)
}
inline std::string* BlockModel::mutable_src_task_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_src_task_id();
  // @@protoc_insertion_point(field_mutable:note.BlockModel.src_task_id)
  return _s;
}
inline const std::string& BlockModel::_internal_src_task_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.src_task_id_.Get();
}
inline void BlockModel::_internal_set_src_task_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_task_id_.Set(value, GetArena());
}
inline std::string* BlockModel::_internal_mutable_src_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.src_task_id_.Mutable( GetArena());
}
inline std::string* BlockModel::release_src_task_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.BlockModel.src_task_id)
  return _impl_.src_task_id_.Release();
}
inline void BlockModel::set_allocated_src_task_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_task_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.src_task_id_.IsDefault()) {
    _impl_.src_task_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.BlockModel.src_task_id)
}

// .note.BlockType block_type = 3;
inline void BlockModel::clear_block_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_type_ = 0;
}
inline ::note::BlockType BlockModel::block_type() const {
  // @@protoc_insertion_point(field_get:note.BlockModel.block_type)
  return _internal_block_type();
}
inline void BlockModel::set_block_type(::note::BlockType value) {
  _internal_set_block_type(value);
  // @@protoc_insertion_point(field_set:note.BlockModel.block_type)
}
inline ::note::BlockType BlockModel::_internal_block_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::note::BlockType>(_impl_.block_type_);
}
inline void BlockModel::_internal_set_block_type(::note::BlockType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_type_ = value;
}

// string body = 4;
inline void BlockModel::clear_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.ClearToEmpty();
}
inline const std::string& BlockModel::body() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.BlockModel.body)
  return _internal_body();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BlockModel::set_body(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.BlockModel.body)
}
inline std::string* BlockModel::mutable_body() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:note.BlockModel.body)
  return _s;
}
inline const std::string& BlockModel::_internal_body() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.body_.Get();
}
inline void BlockModel::_internal_set_body(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.Set(value, GetArena());
}
inline std::string* BlockModel::_internal_mutable_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.body_.Mutable( GetArena());
}
inline std::string* BlockModel::release_body() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.BlockModel.body)
  return _impl_.body_.Release();
}
inline void BlockModel::set_allocated_body(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.body_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.BlockModel.body)
}

// -------------------------------------------------------------------

// PropValueModel

// string prop_id = 1;
inline void PropValueModel::clear_prop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_id_.ClearToEmpty();
}
inline const std::string& PropValueModel::prop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PropValueModel.prop_id)
  return _internal_prop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PropValueModel::set_prop_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.PropValueModel.prop_id)
}
inline std::string* PropValueModel::mutable_prop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prop_id();
  // @@protoc_insertion_point(field_mutable:note.PropValueModel.prop_id)
  return _s;
}
inline const std::string& PropValueModel::_internal_prop_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prop_id_.Get();
}
inline void PropValueModel::_internal_set_prop_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_id_.Set(value, GetArena());
}
inline std::string* PropValueModel::_internal_mutable_prop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.prop_id_.Mutable( GetArena());
}
inline std::string* PropValueModel::release_prop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PropValueModel.prop_id)
  return _impl_.prop_id_.Release();
}
inline void PropValueModel::set_allocated_prop_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prop_id_.IsDefault()) {
    _impl_.prop_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.PropValueModel.prop_id)
}

// string prop_name = 2;
inline void PropValueModel::clear_prop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_name_.ClearToEmpty();
}
inline const std::string& PropValueModel::prop_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PropValueModel.prop_name)
  return _internal_prop_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PropValueModel::set_prop_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.PropValueModel.prop_name)
}
inline std::string* PropValueModel::mutable_prop_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prop_name();
  // @@protoc_insertion_point(field_mutable:note.PropValueModel.prop_name)
  return _s;
}
inline const std::string& PropValueModel::_internal_prop_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prop_name_.Get();
}
inline void PropValueModel::_internal_set_prop_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_name_.Set(value, GetArena());
}
inline std::string* PropValueModel::_internal_mutable_prop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.prop_name_.Mutable( GetArena());
}
inline std::string* PropValueModel::release_prop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PropValueModel.prop_name)
  return _impl_.prop_name_.Release();
}
inline void PropValueModel::set_allocated_prop_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prop_name_.IsDefault()) {
    _impl_.prop_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.PropValueModel.prop_name)
}

// .note.PropertyType prop_type = 3;
inline void PropValueModel::clear_prop_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_type_ = 0;
}
inline ::note::PropertyType PropValueModel::prop_type() const {
  // @@protoc_insertion_point(field_get:note.PropValueModel.prop_type)
  return _internal_prop_type();
}
inline void PropValueModel::set_prop_type(::note::PropertyType value) {
  _internal_set_prop_type(value);
  // @@protoc_insertion_point(field_set:note.PropValueModel.prop_type)
}
inline ::note::PropertyType PropValueModel::_internal_prop_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::note::PropertyType>(_impl_.prop_type_);
}
inline void PropValueModel::_internal_set_prop_type(::note::PropertyType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prop_type_ = value;
}

// .note.PropValueType values = 4;
inline bool PropValueModel::has_values() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.values_ != nullptr);
  return value;
}
inline void PropValueModel::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.values_ != nullptr) _impl_.values_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::note::PropValueType& PropValueModel::_internal_values() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::note::PropValueType* p = _impl_.values_;
  return p != nullptr ? *p : reinterpret_cast<const ::note::PropValueType&>(::note::_PropValueType_default_instance_);
}
inline const ::note::PropValueType& PropValueModel::values() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PropValueModel.values)
  return _internal_values();
}
inline void PropValueModel::unsafe_arena_set_allocated_values(::note::PropValueType* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.values_);
  }
  _impl_.values_ = reinterpret_cast<::note::PropValueType*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:note.PropValueModel.values)
}
inline ::note::PropValueType* PropValueModel::release_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::note::PropValueType* released = _impl_.values_;
  _impl_.values_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::note::PropValueType* PropValueModel::unsafe_arena_release_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PropValueModel.values)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::note::PropValueType* temp = _impl_.values_;
  _impl_.values_ = nullptr;
  return temp;
}
inline ::note::PropValueType* PropValueModel::_internal_mutable_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.values_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::note::PropValueType>(GetArena());
    _impl_.values_ = reinterpret_cast<::note::PropValueType*>(p);
  }
  return _impl_.values_;
}
inline ::note::PropValueType* PropValueModel::mutable_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::note::PropValueType* _msg = _internal_mutable_values();
  // @@protoc_insertion_point(field_mutable:note.PropValueModel.values)
  return _msg;
}
inline void PropValueModel::set_allocated_values(::note::PropValueType* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.values_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.values_ = reinterpret_cast<::note::PropValueType*>(value);
  // @@protoc_insertion_point(field_set_allocated:note.PropValueModel.values)
}

// -------------------------------------------------------------------

// PropValueType

// string multiple = 1;
inline bool PropValueType::has_multiple() const {
  return value_type_case() == kMultiple;
}
inline void PropValueType::set_has_multiple() {
  _impl_._oneof_case_[0] = kMultiple;
}
inline void PropValueType::clear_multiple() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_type_case() == kMultiple) {
    _impl_.value_type_.multiple_.Destroy();
    clear_has_value_type();
  }
}
inline const std::string& PropValueType::multiple() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PropValueType.multiple)
  return _internal_multiple();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PropValueType::set_multiple(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_type_case() != kMultiple) {
    clear_value_type();

    set_has_multiple();
    _impl_.value_type_.multiple_.InitDefault();
  }
  _impl_.value_type_.multiple_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.PropValueType.multiple)
}
inline std::string* PropValueType::mutable_multiple() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_multiple();
  // @@protoc_insertion_point(field_mutable:note.PropValueType.multiple)
  return _s;
}
inline const std::string& PropValueType::_internal_multiple() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (value_type_case() != kMultiple) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_type_.multiple_.Get();
}
inline void PropValueType::_internal_set_multiple(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_type_case() != kMultiple) {
    clear_value_type();

    set_has_multiple();
    _impl_.value_type_.multiple_.InitDefault();
  }
  _impl_.value_type_.multiple_.Set(value, GetArena());
}
inline std::string* PropValueType::_internal_mutable_multiple() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_type_case() != kMultiple) {
    clear_value_type();

    set_has_multiple();
    _impl_.value_type_.multiple_.InitDefault();
  }
  return _impl_.value_type_.multiple_.Mutable( GetArena());
}
inline std::string* PropValueType::release_multiple() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PropValueType.multiple)
  if (value_type_case() != kMultiple) {
    return nullptr;
  }
  clear_has_value_type();
  return _impl_.value_type_.multiple_.Release();
}
inline void PropValueType::set_allocated_multiple(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_value_type()) {
    clear_value_type();
  }
  if (value != nullptr) {
    set_has_multiple();
    _impl_.value_type_.multiple_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.PropValueType.multiple)
}

// string single = 2;
inline bool PropValueType::has_single() const {
  return value_type_case() == kSingle;
}
inline void PropValueType::set_has_single() {
  _impl_._oneof_case_[0] = kSingle;
}
inline void PropValueType::clear_single() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_type_case() == kSingle) {
    _impl_.value_type_.single_.Destroy();
    clear_has_value_type();
  }
}
inline const std::string& PropValueType::single() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:note.PropValueType.single)
  return _internal_single();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PropValueType::set_single(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_type_case() != kSingle) {
    clear_value_type();

    set_has_single();
    _impl_.value_type_.single_.InitDefault();
  }
  _impl_.value_type_.single_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:note.PropValueType.single)
}
inline std::string* PropValueType::mutable_single() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_single();
  // @@protoc_insertion_point(field_mutable:note.PropValueType.single)
  return _s;
}
inline const std::string& PropValueType::_internal_single() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (value_type_case() != kSingle) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_type_.single_.Get();
}
inline void PropValueType::_internal_set_single(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_type_case() != kSingle) {
    clear_value_type();

    set_has_single();
    _impl_.value_type_.single_.InitDefault();
  }
  _impl_.value_type_.single_.Set(value, GetArena());
}
inline std::string* PropValueType::_internal_mutable_single() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value_type_case() != kSingle) {
    clear_value_type();

    set_has_single();
    _impl_.value_type_.single_.InitDefault();
  }
  return _impl_.value_type_.single_.Mutable( GetArena());
}
inline std::string* PropValueType::release_single() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:note.PropValueType.single)
  if (value_type_case() != kSingle) {
    return nullptr;
  }
  clear_has_value_type();
  return _impl_.value_type_.single_.Release();
}
inline void PropValueType::set_allocated_single(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_value_type()) {
    clear_value_type();
  }
  if (value != nullptr) {
    set_has_single();
    _impl_.value_type_.single_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:note.PropValueType.single)
}

inline bool PropValueType::has_value_type() const {
  return value_type_case() != VALUE_TYPE_NOT_SET;
}
inline void PropValueType::clear_has_value_type() {
  _impl_._oneof_case_[0] = VALUE_TYPE_NOT_SET;
}
inline PropValueType::ValueTypeCase PropValueType::value_type_case() const {
  return PropValueType::ValueTypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace note


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::note::PropertyType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::note::PropertyType>() {
  return ::note::PropertyType_descriptor();
}
template <>
struct is_proto_enum<::note::BlockType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::note::BlockType>() {
  return ::note::BlockType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // note_5fmodel_2eproto_2epb_2eh
